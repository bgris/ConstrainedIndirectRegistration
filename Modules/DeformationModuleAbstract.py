#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Sun Jan 28 21:24:28 2018

@author: barbara
"""





# Imports for common Python 2/3 codebase
#from __future__ import print_function, division, absolute_import
from future import standard_library
standard_library.install_aliases()
from builtins import object
from builtins import super


import numpy as np

import odl
from scipy.linalg import block_diag
__all__ = ('DeformationModule', )



class DeformationModule(object):
    """Abstract deformation module


    **Abstract attributes and methods**

    `DeformationModuleAbstract` is an **abstract** class, i.e. it can only be
    subclassed, not used directly.

    Any subclass of `DeformationModuleAbstract` must have the following
    attributes:
        ''GDspace'' : space of geometrical descriptor
                      it must be a vector space
        ''Contspace'' : space of controls
                      it must be a vector space
        ''basisGD'' : orthonormal basis of GDspace
                      list of elements of GDspace
        ''basisCont'' : orthonormal basis of Contspace
                      list of elements of Contspace
        ''basisContTraj'' : orthonormal basis of L^2([0,1],Contspace)
                      discretized (it is a list of lists of list of elements
                      of Contspace)
        ''DomainField'' : set
                        space on wich vector fields will be defined


    and the following methods :
        
       ''ComputeField'': Computes the generated vector field
                            operator with domain = GDspace x Contspace
                            and range =DomainField.tangent_bundle
                            (space of vector fields)
       '' AdjointComputeField'' : Adjoint of field generator
                           operator with domain = GDspace x DomainField.tangent_bundle
                           and range = Contspace
       ''ComputeFieldEvaluate'': Computes the application of the generated vector
                           field on given points
                            python function with domain = 
                            GDspace x Contspace x list of points
                            and range = list of speeds
       ''ComputeFieldEvaluateDer'': Computes the application of the 
                           differential of the generated vector
                           field on given points and vectors
                            python function with domain = 
                            GDspace x Contspace x list of points x list of vectors
                            and range = list of speeds
        ''AdjointDerEvaluate'': Computes the adjoint of the differential of the 
                            generated vector field with respect to geometrical
                            descriptor
                            python function with domain = 
                            GDspace x Contspace x list of points x tangent bundle
                            and range =  T o âˆ— O (\simeq GDspace which is
                            supposed to be an open set of a vector space)
        '' ApplyField '' : applies a given vector field to given deformation
                            module
                            domain = GDspace x tangent_bundle
                            range = T_oO \simeq GDspace which is
                            supposed to be an open set of a vector space
        '' ApplyModule'' : applies the vector field generated by a given module
                           for given GD and controls to a given GD
                           domain = GDspace x Module' x GDspace' x Contspace'
                           range  = T_oO \simeq GDspace which is
                            supposed to be an open set of a vector space
        '' AdjointApply '' : application of the adjoint of ApplyField
                            to a momentum 
                            domain = T * O \simeq GDspace x GDspace (supposed
                            to be an open set of a vector space)
                            range : V* represented in tangent_bundle (L2
                            pairing)
        '' AdjointDerApply '' :   Adjoint of derivative of ApplyField with
                            respect to GD for given GD and vector field, 
                            applied to a momentum
                            domain = GDspace x v x GDspace (GDspace \simeq T_o*O)
                            range = T_o *O \simeq GDspace
        '' AdjointDerApplyMod '' : Adjoint of derivative of ApplyMod with
                            respect to GD for given GD and other Mod with GD', Cont', 
                            applied to a momentum
                            domain = GDspace x GDspace x Mod' x GDspace' x Contspace' (GDspace \simeq T_o*O)
                            range = T_o *O \simeq GDspace
        '' Cost '' : cost function
                    domain = GDspace x Contspace
                    range = real numbers
        '' DerCost '' : differential of cost function
                    domain =  GDspace x Contspace
                    range = T_o *O \simeq GDspace
        '' InvCo '' : inversion of the matrix C_o such that cost(o,h) = h^T C_o h
                    domain = GDspace
                    range = matrix of size dimContspace
                    
    
    """


    def __init__(self,GDspace,Contspace,DomainField):
        """Initialize a new instance.
        """

        self.GDspace=GDspace
        self.Contspace=Contspace
        self.domain=DomainField
        #print(1)

        self.DomainField=DomainField


    def get_columnvector_control(self, Cont):
        """
        return controls as a column vector
        """

        raise odl.OpNotImplementedError('get_columnvector_control not implemented '
                                        'for operator {!r}'
                                        ''.format(self))
        
    def get_spaceelement_control(self, Cont_vector):
        """
        return controls as a Contspace.element
        """

        raise odl.OpNotImplementedError('get_spaceelement_control not implemented '
                                        'for operator {!r}'
                                        ''.format(self))
        
    def ComputeField(self, o,h):
        """Return the computed vector field on DomainField
        """

        raise odl.OpNotImplementedError('ComputeField not implemented '
                                        'for operator {!r}'
                                        ''.format(self))



    def AdjointComputeField(self, o,v):
        """Return the computed vector field on DomainField
        """

        raise odl.OpNotImplementedError('AdjointComputeField not implemented '
                                        'for operator {!r}'
                                        ''.format(self))





#    @property
    def ComputeFieldEvaluate(self, o, h, points):
        """Return the computed vector field applied to
           a given point
        """
        raise odl.OpNotImplementedError('ComputeFieldEvaluate not implemented '
                                    'for operator {!r}'
                                    ''.format(self))
#    @property
    def ComputeFieldEvaluateDer(self, o, h, points, vectors):

        raise odl.OpNotImplementedError('ComputeFieldEvaluateDer not implemented '
                                        'for operator {!r}'
                                        ''.format(self))

#    @property
    def AdjointDerEvaluate(self, o, h, vect_field):
        
        raise odl.OpNotImplementedError('AdjointDerEvaluate not implemented '
                                    'for operator {!r}'
                                    ''.format(self))

#    @property
    def ApplyField(self, o,v):

        raise odl.OpNotImplementedError('ApplyField not implemented '
                                        'for operator {!r}'
                                        ''.format(self))


#    @property
    def ApplyModule(self, GD, Module, GDmod, Contmod):

        raise odl.OpNotImplementedError('ApplyModule not implemented '
                                        'for operator {!r}'
                                        ''.format(self))


#    @property
    def AdjointApply(self, GD, Mom):

        raise odl.OpNotImplementedError('AdjointApply not implemented '
                                        'for operator {!r}'
                                        ''.format(self))


#    @property
    def AdjointDerApply(self,GD, Mom, vect_field):

        raise odl.OpNotImplementedError('AdjointDerApply not implemented '
                                        'for operator {!r}'
                                        ''.format(self))

#    @property
    def AdjointDerApplyMod(self, o, Mom, Mod, GDMod, ContMod):

        raise odl.OpNotImplementedError('AdjointDerApplyMod not implemented '
                                        'for operator {!r}'
                                        ''.format(self))



#    @property
    def Cost(self, GD,Cont):

        raise odl.OpNotImplementedError('Cost not implemented '
                                        'for operator {!r}'
                                        ''.format(self))


#    @property
    def DerCost(self, GD,Cont):

        raise odl.OpNotImplementedError('DerCost not implemented '
                                        'for operator {!r}'
                                        ''.format(self))


#    @property
    def InvCo(self, GD):

        raise odl.OpNotImplementedError('InvCo not implemented '
                                        'for operator {!r}'
                                        ''.format(self))




class Compound(DeformationModule):
    def __init__(self,ModulesList):
        self.ModulesList=ModulesList
        domain=ModulesList[0].DomainField
        self.Nmod=len(ModulesList)
        for i in range(1,self.Nmod):
          if not (ModulesList[i].DomainField==domain):
              print('Problem domains')

        GDspace=odl.ProductSpace(*[ModulesList[i].GDspace for i in range(self.Nmod)])
        Contspace=odl.ProductSpace(*[ModulesList[i].Contspace for i in range(self.Nmod)])


        self.dim=ModulesList[0].DomainField.ndim
        
        self.dimCont = sum([Modi.dimCont for Modi in ModulesList])


        super().__init__(GDspace,Contspace,domain)


    def get_columnvector_control(self, Cont):
        """
        return controls as a column vector
        """
        
        return np.concatenate([self.ModulesList[i].get_columnvector_control(Cont[i]) for i in range(self.Nmod)])

        
    def get_spaceelement_control(self, Cont_vector):
        """
        return controls as a Contspace.element
        """
        Cont = []
        uu = 0
        for Modi in self.ModulesList:
            Cont.append(Modi.get_spaceelement_control(Cont_vector[uu : uu + Modi.dimCont]))
            uu += Modi.dimCont
        return self.Contspace.element(Cont)

    def ComputeField(self, o,h):
        vector_field=self.DomainField.tangent_bundle.zero()
        for i in range(self.Nmod):
            vector_field+=self.ModulesList[i].ComputeField(o[i],h[i]).copy()

        return vector_field


    def AdjointComputeField(self, o,v):
        """Return the computed vector field on DomainField
        """
        
        return self.Contspace.element([self.ModulesList[i].AdjointComputeField(o[i], v) for i in range(self.Nmod)])

    def ComputeFieldEvaluate(self, o, h, points):
        return sum([self.ModulesList[i].ComputeFieldEvaluate(o[i], h[i], points) for i in range(self.Nmod)])        

    def ComputeFieldEvaluateDer(self, o, h, points, vectors):
        return sum([self.ModulesList[i].ComputeFieldEvaluateDer(o[i], h[i], points, vectors) for i in range(self.Nmod)])
    
    def AdjointDerEvaluate(self, o, h, vect_field):
        return self.GDspace.element([self.ModulesList[i].AdjointDerEvaluate(o[i], h[i], vect_field) for i in range(self.Nmod)])

        
    def ApplyField(self,GD,vect_field):
        return self.GDspace.element([self.ModulesList[i].ApplyField(GD[i], vect_field) for i in range(self.Nmod)])
       
    def ApplyModule(self, GD, Module, GDmod, Contmod):
        return self.GDspace.element([self.ModulesList[i].ApplyModule(GD[i], Module, GDmod, Contmod) for i in range(self.Nmod)])
        
    def AdjointApply(self, GD, Mom):
        return sum([self.ModulesList[i].AdjointApply(GD[i], Mom[i]) for i in range(self.Nmod)])
    
    def AdjointDerApply(self, GD, Mom, vect_field):
        return self.GDspace.element([self.ModulesList[i].AdjointDerApply(GD[i], Mom[i], vect_field) for i in range(self.Nmod)])
        
    def AdjointDerApplyMod(self, GD, Mom, Mod, GDMod, ContMod):
        return self.GDspace.element([self.ModulesList[i].AdjointDerApplyMod(GD[i], Mom[i], Mod, GDMod, ContMod) for i in range(self.Nmod)])
        
    def Cost(self,GD,Cont):
        return sum([self.ModulesList[i].Cost(GD[i], Cont[i]) for i in range(self.Nmod)])   

    def DerCost(self, GD, Cont):
        return self.GDspace.element([self.ModulesList[i].DerCost(GD[i], Cont[i]) for i in range(self.Nmod)])
    
    def InvCo(self, GD):
        return block_diag(*[self.ModulesList[i].InvCo(GD[i]) for i in range(self.Nmod)])
    
#    